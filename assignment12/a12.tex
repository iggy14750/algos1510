\documentclass{article}
\author{Isaac B Goss\\ James Hahn\\ Jonathan Dyer}
\title{Assignment 12}

\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{enumitem}
\usepackage[margin=0.8in]{geometry}
\usepackage{graphicx}

% ============ USED FOR OUR FORMAT ============
\newtheorem{thm}{Claim}
\providecommand{\prob}[1]{\section*{Problem #1}}
\providecommand{\soln}{\textbf{Solution: }}
\providecommand{\image}[1]{
    \begin{center}
        \includegraphics%[width=0.95\textwidth]
            {#1}
    \end{center}
}
\providecommand{\tightlist}{
    \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}
}

% ============ USED FOR CODE LISTINGS ============
\usepackage{listings}
\usepackage[usenames,dvipsnames,svgnames]{xcolor}
\definecolor{javagreen}{rgb}{0.25,0.5,0.35}
\lstset{
    basicstyle   = \footnotesize,
    commentstyle = \color{javagreen},
    frame        = single,
    language     = C,
    stringstyle  = \color{orange},
    numbers      = left,
    showstringspaces=false,
    deletekeywords = {len, max, format, min},
    morekeywords = {yield, function, then, do, to},
    keywordstyle = \color{blue},
}


\begin{document}
\maketitle
	\prob{11}
	\textbf{Part A} Consider the below code from class as the array-based solution to the Knapsack problem:

	\begin{lstlisting}[escapeinside={(*}{*)}]
A[0, 0] = 0
for i = 0 to n do
	for w = 0 to L do
		if A[i, w] is defined then
			A[i+1, w] = max(A[i, w], A[i+1, w])
			A[i+1, w + (*$w_{i+1}$*)] = max(A[i+1, w + (*$w_{i+1}$*)], A[i, w] + (*$v_{i+1}$*)])])
output (*$max_{0{\leq}w{\leq}}$*)A[n, w]
	\end{lstlisting}

	This produces the following matrix:

	\image{knapsack}

	The above table represents the output array from the input items where $v$ represents the values of the items and $w$ represents the weights of the items:
	\begin{enumerate}
		\item $v_1$ = 5, $w_1$ = 1
		\item $v_2$ = 7, $w_2$ = 2
		\item $v_3$ = 12, $w_3$ = 3
	\end{enumerate}

	In this image, $n$ is the level of the tree that we're currently at.  As we go down the tree and for each node, we can either add the current item $v_i$ into our backpack, increasing the weight and value of a node's right child, or don't add it, directly translating a node's contents into its left child.  The red arrows indicate this thought; for every node, there are two red arrows that spawn and point to its two child nodes in the tree.  Once we have filled out the tree and created all permutations, or subsets, of the items, we can choose the index in the bottom row of the table with the highest value that doesn't go past our weight limit $L$.  In this scenario, it is item weight of sum 24.

	In order to trace this backwards to find the actual set of items, we start from this solution/optimal node and look at its parent.  If the parent contains the same value, we didn't add item $i$'s value, $v_i$, to the backpack.  Otherwise, if the difference between a node's value and its parent node's value is $v_i$, then we know item $i$ was added to the backpack.  In this case, we can add item $i$ to our set of items and keep track of it until we reach the root of the tree.  We continue this process until we reach index $0,0$ of the array, which is the root of the tree.  At this point, we have backtracked from the optimal solution, determining at every level whether we took a specific item and added it to the backpack.

	If we have the output array $A$, the following code will execute the aforementioned strategy:

	\begin{lstlisting}[escapeinside={(*}{*)}]
	// Store the optimal results index
	x = index of (*$max_{0{\leq}w{\leq}L}$*)A[n, w] // How far right the solution is in the last row
	y = n // The optimal solution is in the last row

	set = {} // The items in our backpack
	for i = n down to 1:
		parent_node = A[i-1, w - (*$w_{i-1}$*)]
		// The change in value from parent to child equals this item's value
		if (A[x, y] - parent_node) == (*$v_i$*) then
			set.add((*$i$*)) // Add item i to the set (our backpack)
		// Set the new coordinates of the node in the array to the parent node so we
		// 	can traverse up the tree.
		x = i-1
		y = w - (*$w_{i-1}$*)
	\end{lstlisting}

	\textbf{Part B} The problem asks us to complete this problem in $O(L)$ space and $O(nL)$ time.\\

	Consider the above code in $part A$.  This accomplishes the $O(nL)$ time requirement because we have two for loops with $i$ iterating over $n$ and $j$ iterating over $L$.  Obviously, $L$ iterations for every $n$ produces a time of $O(nL)$.  \\

	The interesting part is doing the problem in $O(L)$ space.  In order to accomplish this, since we don't need to find the actual set of items, we can simply use two arrays of size $L$.  If you noticed in $part A$ of the problem, in order to calculate any given level of the tree, or row in the array, we simply needed the preceding row's information.  This is because the "preceding row" contained the total value sum of the items for every node at that level in the tree and we knew the weight of the items by how far right they were in the array because that was our measure of $L$.\\

	So, our solution is to use two arrays of size $L$, which can be completed in the above time and space requirements with the following code:
	\begin{lstlisting}[escapeinside={(*}{*)}]
Let A be a one-dimensional array of size L
Let B be a one-dimensional array of size L
// Base case, no items, so 0 value and 0 weight
A[0] = 0

for i = 0 to n do // For each level in our tree
	for w = 0 to L do // For each node in that level (*$i$*)
		if i % 2 == 0 then // On even numbered levels, write to B
			if A[w] is defined then
				B[w] = max(A[w], B[w])
				B[w + (*$w_{i+1}$*)] = max(B[w + (*$w_{i+1}$*)], A[w] + (*$v_{i+1}$*)])])
		else // On odd numbered levels, write to A
			if B[w] is defined then
				A[w] = max(B[w], A[w])
				A[w + (*$w_{i+1}$*)] = max(A[w + (*$w_{i+1}$*)], B[w] + (*$v_{i+1}$*)])])
// Depending on whether n is even or odd, we need to know which array, A or B, to check
if n is even:
	output (*$max_{0{\leq}w{\leq}L}$*)A[n, w]
else
	output (*$max_{0{\leq}w{\leq}L}$*)B[n, w]
	\end{lstlisting}

\prob{15}








\prob{16}
Input: positive integers $v_1, \dots , v_n$\\
Output: A subset S of the integers such that $\sum_{v_i \in S}v_i^3 = \prod_{v_i \in S}v_i$.\par \medskip
\soln
Let us consider the typical binary tree for subsets, wherein at each of the $n$ levels the number $v_i$ is either selected to be a part of our subset S or not. Without being pruned, this tree would enumerate all $2^n$ subsets of the set $V = \{v_1,\dots,v_n\}$. However, given the constraint in the problem we can immediately recognize some helpful pruning rules:\par



\end{document}
