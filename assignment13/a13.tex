\documentclass{article}
\author{Isaac B Goss\\ James Hahn\\ Jonathan Dyer}
\title{Assignment 13}

\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{enumitem}
\usepackage[margin=0.8in]{geometry}
\usepackage{graphicx}

% ============ USED FOR OUR FORMAT ============
\newtheorem{thm}{Claim}
\providecommand{\prob}[1]{\section*{Problem #1}}
\providecommand{\soln}{\textbf{Solution: }}
\providecommand{\image}[1]{
    \begin{center}
        \includegraphics%[width=0.95\textwidth]
            {#1}
    \end{center}
}
\providecommand{\tightlist}{
    \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}
}

% ============ USED FOR CODE LISTINGS ============
\usepackage{listings}
\usepackage[usenames,dvipsnames,svgnames]{xcolor}
\definecolor{javagreen}{rgb}{0.25,0.5,0.35}
\lstset{
    basicstyle   = \footnotesize,
    commentstyle = \color{javagreen},
    frame        = single,
    language     = C,
    stringstyle  = \color{orange},
    numbers      = left,
    showstringspaces=false,
    deletekeywords = {len, max, format, min},
    morekeywords = {yield, function, then, do, to},
    keywordstyle = \color{blue},
}


\begin{document}
\maketitle

    \prob{19}
    \begin{enumerate}[label=(\alph*)]
        \item Create a recursive solution to the problem.
            Let $i$ be an index into the $T$ sequence, and likewise for $j$ and $P$.
            \begin{lstlisting}[escapeinside={(*}{*)}]
function MAWS(i, j)
    if j == 0 then return 0 // End of P; success!
    if i == 0 then return failure // Reached the end of T without covering all of P

    if (*$t_i$*) == (*$p_j$*) then
        return max(
            MAWS(i - 1, j), // Exclude (*$t_i$*)
            MAWS(i - 1, j - 1) + (*$c_i$*)) // Include (*$t_i$*)
    else
        return MAWS(i - 1, j) // Exclude by default.
            \end{lstlisting}
        \item Give a dynamic programming algorithm based on enumerating the subsequences of $T$ and using pruning.
            Consider the typical subset enumeration tree over the elements of $T$.
            For this tree, we have the following pruning rule:
            \begin{enumerate}[label=\arabic*.]
                \item When considering two nodes on the same level with the same length subsequence, choose the more expensive one.
            \end{enumerate}

            With this, we get the following code.
            \begin{lstlisting}[escapeinside={(*}{*)}]
let A[i, j] = an n+1(*$\times$*)k+1 matrix which represents the most
    high-valued subsequence of (*$t_1,\dots,t_i$*) with length j.
A[0, 0] = 0

for i = 1 to n do
    for j = 1 to k do
        if A[i-1, j] is defined then
            A[i, j] = max(A[i-1, j], A[i, j]) // Leave out (*$t_i$*)
            if (*$t_i$*) == (*$p_j$*) then
                A[i, j+1] = max(A[i, j+1], A[i-1, j] + (*$c_i$*)) // Include (*$t_i$*)

output A[n, k] // If no such sequence exists, then output is undefined, as per problem.
            \end{lstlisting}

        \item Give a dynamic programming algorithm based on enumerating the subsequences of $P$ and using pruning.
    \end{enumerate}

    \prob{22}


\end{document}

























