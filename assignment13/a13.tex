\documentclass{article}
\author{Isaac B Goss\\ James Hahn\\ Jonathan Dyer}
\title{Assignment 13}

\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{enumitem}
\usepackage[margin=0.8in]{geometry}
\usepackage{graphicx}

% ============ USED FOR OUR FORMAT ============
\newtheorem{thm}{Claim}
\providecommand{\prob}[1]{\section*{Problem #1}}
\providecommand{\soln}{\textbf{Solution: }}
\providecommand{\image}[1]{
    \begin{center}
        \includegraphics%[width=0.95\textwidth]
            {#1}
    \end{center}
}
\providecommand{\tightlist}{
    \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}
}

% ============ USED FOR CODE LISTINGS ============
\usepackage{listings}
\usepackage[usenames,dvipsnames,svgnames]{xcolor}
\definecolor{javagreen}{rgb}{0.25,0.5,0.35}
\lstset{
    basicstyle   = \footnotesize,
    commentstyle = \color{javagreen},
    frame        = single,
    language     = C,
    stringstyle  = \color{orange},
    numbers      = left,
    showstringspaces=false,
    deletekeywords = {len, max, format, min},
    morekeywords = {yield, function, then, do, to},
    keywordstyle = \color{blue},
}


\begin{document}
\maketitle

    \prob{19}
    \begin{enumerate}[label=(\alph*)]
        \item Create a recursive solution to the problem.
            Let $i$ be an index into the $T$ sequence, and likewise for $j$ and $P$.
            \begin{lstlisting}[escapeinside={(*}{*)}]
function MAWS(i, j)
    if j == 0 then return 0 // End of P; success!
    if i == 0 then return failure // Reached the end of T without covering all of P

    if (*$t_i$*) == (*$p_j$*) then
        return max(
            MAWS(i - 1, j), // Exclude (*$t_i$*)
            MAWS(i - 1, j - 1) + (*$c_i$*)) // Include (*$t_i$*)
    else
        return MAWS(i - 1, j) // Exclude by default.
            \end{lstlisting}
        \item Give a dynamic programming algorithm based on enumerating the subsequences of $T$ and using pruning.
            Consider the typical subset enumeration tree over the elements of $T$.
            For this tree, we have the following pruning rule:
            \begin{enumerate}[label=\arabic*.]
                \item When considering two nodes on the same level with the same length subsequence, choose the more expensive one.
            \end{enumerate}

            With this, we get the following code.
            \begin{lstlisting}[escapeinside={(*}{*)}]
let A[i, j] = an n+1(*$\times$*)k+1 matrix which represents the most
    high-valued subsequence of (*$t_1,\dots,t_i$*) with length j.
A[0, 0] = 0

for i = 1 to n do
    for j = 1 to k do
        if A[i-1, j] is defined then
            A[i, j] = max(A[i-1, j], A[i, j]) // Leave out (*$t_i$*)
            if (*$t_i$*) == (*$p_j$*) then
                A[i, j+1] = max(A[i, j+1], A[i-1, j] + (*$c_i$*)) // Include (*$t_i$*)

output A[n, k] // If no such sequence exists, then output is undefined, as per problem.
            \end{lstlisting}

        \item Give a dynamic programming algorithm based on enumerating the subsequences of $P$ and using pruning.
    \end{enumerate}

    \pagebreak
    \prob{22}
    Given a tree which at each node, branches to buy a Bahn card for each trip or not, we can develop the following pruning rules.
    \begin{enumerate}
        \item If there is a Bahn card active at a particular node, then we don't need to buy a new one.
        \item Only the last Bahn card purchased needs to be taken into account when making this decision.
        \item We can buy at most $n$ Bahn cards, one for each trip.
        \item Given two nodes on the same level which have the same number of discounted days left, then choose the one with the least overall cost.
    \end{enumerate}

    \begin{lstlisting}[escapeinside={(*}{*)}]
let A[i, j] = an n+1(*$\times$*)n+1 matrix with the cost of the least expensive
    way to travel to locations (*$T_1,\dots,T_i$*) given that the last Bahn card
    was purchased for trip j.
A[0, 0] = 0

function activeBahnCard(i, j)
    if j == 0 then return False
    return (*$d_i$*) - (*$d_j \leq $*) L

for i = 1 to n do
    for j = 0 to n do
        if A[i-1, j] is defined then
            if activeBahnCard(i, j) then
                // Not considering buying a new Bahn card.
                A[i, j] = min(A[i, j], A[i-1, j] + (*$\frac{1}{2}f_i$*))
            else
                A[i, j] = min(A[i, j], A[i-1, j] + (*$f_i$*)) // Not buying a new Bahn card
                A[i, i] = min(A[i, j], A[i-1, j] + B + (*$\frac{1}{2}f_i$*)) // Here we are buying a new one.
output (*$\displaystyle\max_{0 \leq j \leq n}$*) A[n, j]
    \end{lstlisting}

\end{document}

























