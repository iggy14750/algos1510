\documentclass{article}
\author{Isaac B Goss\\ James Hahn\\ Jonathan Dyer}
\title{Assignment 15}

\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{enumitem}
\usepackage[margin=0.8in]{geometry}
\usepackage{graphicx}

% ============ USED FOR OUR FORMAT ============
\newtheorem{thm}{Claim}
\providecommand{\prob}[1]{\section*{Problem #1}}
\providecommand{\soln}{\textbf{Solution: }}
\providecommand{\image}[1]{
    \begin{center}
        \includegraphics%[width=0.95\textwidth]
            {#1}
    \end{center}
}
\providecommand{\tightlist}{
    \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}
}

% ============ USED FOR CODE LISTINGS ============
\usepackage{listings}
\usepackage[usenames,dvipsnames,svgnames]{xcolor}
\definecolor{javagreen}{rgb}{0.25,0.5,0.35}
\lstset{
    basicstyle   = \footnotesize,
    commentstyle = \color{javagreen},
    frame        = single,
    language     = C,
    stringstyle  = \color{orange},
    numbers      = left,
    showstringspaces=false,
    deletekeywords = {len, max, format, min},
    morekeywords = {yield, function, then, do, to},
    keywordstyle = \color{blue},
    escapeinside={(*}{*)}
}


\begin{document}
\maketitle

\begin{prob} {23}
	Give a polynomial time algorithm for the following problem. The input consists of a sequence
	$R$ = $R_0$, \dots , $R_n$ of non-negative integers, and an integer $k$. The number $R_i$ represents the number
	of users requesting some particular piece of information at time $i$ ( say from a www server. If the
	server broadcasts this information at some time $t$, the the requests of all the users who requested the
	information strictly before time $t$ are satisfied. The server can broadcast this information at most
	$k$ times. The goal is to pick the $k$ times to broadcast in order to minimize the total time (over all
	requests) that requests/users have to wait in order to have their requests satisfied.\\
	
	Let's use the binary tree that we utilize for in-class examples to show our thought process for this problem.
	
	\image{treeOfSets}
	
	At every level in this tree, we can either choose to add time $t$ to our set of times that we send out the piece of information (indicated by the right child of each node), or we can not add time $t$ to the set (indicated by the left child).\\
	
	To prune this tree, we have created two simple rules:
	\begin{enumerate}
		\item If the size of a set at a given node is greater than $k$, prune that subtree.  This is because we can't use more than $k$ times anyway, so it'd be a waste of our time to explore that subtree.
		\item If two sets at the same level have the same total waiting time, prune the set with more times in it.  Basically, if they both have the same waiting time, then they'll both have identical subtrees and permutations of times added to either in the future.  The reason we want to prune the set with more times in it at the moment is because we'll have more freedom with the smaller set to allocate times in the future, thus more availability to limit the waiting time.
	\end{enumerate}

	As a result, our code looks like this:
	
	\begin{lstlisting}
A[0, (*$\emptyset$*)] = 0 // Haven't started timing requests set, so our wait time is 0
// A[n, k] = minimum total waiting time of all persons at times in set k 
for (*$i$*) = 0 to (*$n$*) do // Go down the levels of our tree
	addToWaitTime = 0
	for (*$j$*) = (*$i$*) to (*$n$*) do // Traverse each child node
		
	if A[n, k] is defined then
		A[n+1, k] = min(A[n, k], A[n+1, k] + ) //MODIFY THIS LINE TO ADD SOME NEW VALUE
		if length(k) < k then // We haven't exceeded our allotted # of times
			A[n+1, k (*$\cup$*) (*$R_i$*)] = min(A[n+1, k (*$\cup$*) (*$R_i$*)], A[n, k])
output min A[n, *]
	\end{lstlisting}
	
	As one can see, our program incorporates two for loops with $k$ iterations for every $n$ to produce a runtime of $O(nk)$.  In the worst case, $n = k$, so the runtime is effectively $O(n^2)$.  This is indeed a polynomial runtime and solves our problem.
\end{prob}


\end{document}

























