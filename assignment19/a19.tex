\documentclass{article}
\author{Isaac B Goss\\ James Hahn\\ Jonathan Dyer}
\title{Assignment 19}

\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{enumitem}
\usepackage[margin=0.8in]{geometry}
\usepackage{graphicx}

% ============ USED FOR OUR FORMAT ============
\newtheorem{thm}{Claim}
\providecommand{\prob}[1]{\section*{Problem #1}}
\providecommand{\soln}{\textbf{Solution: }}
\providecommand{\image}[1]{
    \begin{center}
        \includegraphics%[width=0.95\textwidth]
            {#1}
    \end{center}
}
\providecommand{\tightlist}{
    \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}
}
\providecommand{\reducible}[2]{
  \textbf{#1} $\leq$ \textbf{#2}
}

% ============ USED FOR CODE LISTINGS ============
\usepackage{listings}
\usepackage[usenames,dvipsnames,svgnames]{xcolor}
\definecolor{javagreen}{rgb}{0.25,0.5,0.35}
\lstset{
    basicstyle   = \footnotesize,
    commentstyle = \color{javagreen},
    frame        = single,
    language     = C,
    stringstyle  = \color{orange},
    numbers      = left,
    showstringspaces=false,
    deletekeywords = {len, max, format, min},
    morekeywords = {yield, function, then, do, to},
    keywordstyle = \color{blue},
    escapeinside={(*}{*)}
}


\begin{document}
\maketitle

\prob{6}

\begin{enumerate}
  \item \reducible{Indepenent Set}{Clique}, and \reducible{Clique}{Indepenent Set} \\
  We define the complement of some graph $G$, labelled $G^C$ to be a graph such that
  \begin{enumerate}
    \item $V(G) = V(G^C)$
    \item $uv \in E(G^C)$ iff $u,v \in V(G^C)$ and $uv \not\in E(G)$.
  \end{enumerate}
  An independent set of vertices are a subset of vertices which are all pairwise non-adjacent.
  Likewise, a clique is a subset of vertices which are all pairwise adjacent.
  In the complement of some graph, all independent sets become cliques, and vice versa.
  Thus we have the following reductions:
  \begin{lstlisting}
function IndepenentSet(G, i)
  return Clique((*$G^C$*), i)
  \end{lstlisting}
  \begin{lstlisting}
function Clique(G, i)
  return IndepenentSet((*$G^C$*), i)
  \end{lstlisting}
  \item \reducible{Indepenent Set}{Vertex Cover} and \reducible{Vertex Cover}{Indepenent Set} \\
  We can define a similar relationship between these two problems, by noting the following:
  \begin{itemize}
    \item Define graph $G$ by it's set of vertices and edges, as $G = (V,E)$.
    \item Note that if $L \subset V$ is an independent set, then for any two neighboring vertices $u$ and $v$, at most one of them is in $L$ or else it wouldn't be an independent set. So then at $least$ one of every pair of neighbors is in $M = V - L$. Thus every edge in $E$ has an endpoint in $M$, so $M$ is a vertex cover.
    \item Conversely, if $M \subset V$ is a vertex cover, then consider any two vertices $x$ and $y$ in $L = V - M$. These two points can't be neighbors, else $M$ wouldn't be a cover. Thus no two points in $L$ are adjacent, so it must be an independent set.
  \end{itemize}
  \begin{lstlisting}
function IndepenentSet(G, k)
  return VertexCover(G, n - k)
  \end{lstlisting}
  \begin{lstlisting}
function VertexCover(G, k)
  return IndepenentSet(G, n - k)
  \end{lstlisting}
\end{enumerate}

With these reductions (which are all obviously polynomial time), we can reduce any of these problems to any other in polynomial time.

\pagebreak

\prob{10}
We can reduce the clique optimization problem to clique decision by simply checking every value of $k$,
beginning at $n = |G|$ and decrementing.
Follow this by a closure operation which removes all vertices with degree less than k-1,
so that only the clique is left.
\begin{lstlisting}
alg cliqueOpt(Graph G)
  let n = |G|
  for k = n to 1 do
    if cliqueDecision(G, k) then                    // we found the largest clique size
      break                                         // so break and find the members

  let H = G
  do
    G = H
    for vertex v in H:
      if degree(v) < k-1 then
        delete v from H
  until H == G

  output H
\end{lstlisting}
If the assumed polynomial `cliqueDecision' algorithm runs in $O(n^j)$ time for some j,
then obviously our `cliqueOpt' algorithm takes $n*O(n^j) = O(n^{j+1})$ time for the first `for' loop.
Then, consider the closure operation.
At each iteration, it must remove at least one vertex (otherwise the loop would terminate).
The worst case is where each iteration, exactly one vertex is deleted, until the clique is reached.
Then, as we need to scan through all of the vertices,
we are looking at a summation of scanning time like $n + (n-1) + (n-2) + \dots + k = O(n^2)$.
Then, overall, we are looking at $O(n^2 + n^{j+1})$, polynomial time.


\prob{12}
We can show that 2Clique is NP-hard by reducing another known NP-hard problem (here cliqueDecision) to it.
That is, we must show that cliqueDecision $\leq$ 2Clique in polynomial time.
We do this by giving an algorithm for cliqueDecision that uses 2Clique:
\begin{lstlisting}
alg cliqueDecision(H,j)   // simply create a new graph which is two copies of the original
  let G = H + H           // if this new graph has two cliques of the desired size, then
  return 2Clique(G,j)     // clearly the original has one
\end{lstlisting}
Obviously, creating a new graph that is just two copies of the original graph H takes $O(n)$ time, which when added to our cliqueDecision algorithm results in a total runtime of $O(n + f(n))$, where $f(n)$ is the runtime of cliqueDecision.

\prob{15}




\end{document}
