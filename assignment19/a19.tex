\documentclass{article}
\author{Isaac B Goss\\ James Hahn\\ Jonathan Dyer}
\title{Assignment 19}

\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{enumitem}
\usepackage[margin=0.8in]{geometry}
\usepackage{graphicx}

% ============ USED FOR OUR FORMAT ============
\newtheorem{thm}{Claim}
\providecommand{\prob}[1]{\section*{Problem #1}}
\providecommand{\soln}{\textbf{Solution: }}
\providecommand{\image}[1]{
    \begin{center}
        \includegraphics%[width=0.95\textwidth]
            {#1}
    \end{center}
}
\providecommand{\tightlist}{
    \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}
}

% ============ USED FOR CODE LISTINGS ============
\usepackage{listings}
\usepackage[usenames,dvipsnames,svgnames]{xcolor}
\definecolor{javagreen}{rgb}{0.25,0.5,0.35}
\lstset{
    basicstyle   = \footnotesize,
    commentstyle = \color{javagreen},
    frame        = single,
    language     = C,
    stringstyle  = \color{orange},
    numbers      = left,
    showstringspaces=false,
    deletekeywords = {len, max, format, min},
    morekeywords = {yield, function, then, do, to},
    keywordstyle = \color{blue},
    escapeinside={(*}{*)}
}


\begin{document}
\maketitle
\prob{6}




\prob{10}
<<<<<<< HEAD
=======
Psh. Child's play.
>>>>>>> 80407ed37ba57999b780beeb5e78ffc1f191db9c
We can reduce the clique optimization problem to clique decision by simply checking every value of $k$,
beginning at $n = |G|$ and decrementing.
In this way we find the order $m$ of the largest clique in linear ($O(n)$) time (times whatever the decision algorithm takes).
Then our task is simply to iterate over subgraphs of order $m$ (maximum of $n*(n-1)*\dots*(m+1)*m$) \
to find which contains the correct set of vertices. See the following code:
\begin{lstlisting}
alg cliqueOpt(Graph G)
  let n = |G|
  for k = n to 1 do
    if cliqueDecision(G, k) then                    // we found the largest clique size
      break                                         // so break and find the members

  for subgraph H (*$\in$*) G where |H| = k do
    if cliqueDecision(H, k) then                    // we found it!
      return H                                      // so return the clique (subgraph)
\end{lstlisting}
If the assumed polynomial `cliqueDecision' algorithm runs in $O(n^j)$ time for some j,
<<<<<<< HEAD
then obviously our `cliqueOpt' algorithm takes $n*O(n^j) = O(n^{j+1})$ time for the first `for' loop.
Then, consider the closure operation.
At each iteration, it must remove at least one vertex (otherwise the loop would terminate).
The worst case is where each iteration, exactly one vertex is deleted, until the clique is reached.
Then, as we need to scan through all of the vertices,
we are looking at a summation of scanning time like $n + (n-1) + (n-2) + \dots + k = O(n^2)$.
Then, overall, we are looking at $O(n^2 + n^{j+1})$, polynomial time.


\prob{12}
Laughable.
=======
then obviously our `cliqueOpt' algorithm takes $n*O(n^j) = O(n^{j+1})$ time for the first `for' loop,
plus up to $O(n^j) * O(n^{n-m})$ time for the second.
Still polynomial, still good. Boom.

\prob{12}
Laughable.
We can show that 2Clique is NP-hard by reducing a known NP-hard problem (in this case cliqueDecision) to it. That is, by showing
cliqueDecision $\leq$ 2Clique. This is easily done with the following code:
>>>>>>> 80407ed37ba57999b780beeb5e78ffc1f191db9c


\prob{15}




\end{document}
