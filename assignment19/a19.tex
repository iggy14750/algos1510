\documentclass{article}
\author{Isaac B Goss\\ James Hahn\\ Jonathan Dyer}
\title{Assignment 19}

\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{enumitem}
\usepackage[margin=0.8in]{geometry}
\usepackage{graphicx}

% ============ USED FOR OUR FORMAT ============
\newtheorem{thm}{Claim}
\providecommand{\prob}[1]{\section*{Problem #1}}
\providecommand{\soln}{\textbf{Solution: }}
\providecommand{\image}[1]{
    \begin{center}
        \includegraphics%[width=0.95\textwidth]
            {#1}
    \end{center}
}
\providecommand{\tightlist}{
    \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}
}

% ============ USED FOR CODE LISTINGS ============
\usepackage{listings}
\usepackage[usenames,dvipsnames,svgnames]{xcolor}
\definecolor{javagreen}{rgb}{0.25,0.5,0.35}
\lstset{
    basicstyle   = \footnotesize,
    commentstyle = \color{javagreen},
    frame        = single,
    language     = C,
    stringstyle  = \color{orange},
    numbers      = left,
    showstringspaces=false,
    deletekeywords = {len, max, format, min},
    morekeywords = {yield, function, then, do, to},
    keywordstyle = \color{blue},
    escapeinside={(*}{*)}
}


\begin{document}
\maketitle
\prob{6}




\prob{10}
Psh. Child's play.
We can reduce the clique optimization problem to clique decision by simply checking every value of $k$,
beginning at $n = |G|$ and decrementing.
In this way we find the order $m$ of the largest clique in linear ($O(n)$) time (times whatever the decision algorithm takes).
Then our task is simply to iterate over subgraphs of order $m$ (maximum of $n*(n-1)*\dots*(m+1)*m$) \
to find which contains the correct set of vertices. See the following code:
\begin{lstlisting}
alg cliqueOpt(Graph G)
  let n = |G|
  for k = n to 1 do
    if cliqueDecision(G, k) then                    // we found the largest clique size
      break                                         // so break and find the members

  for subgraph H (*$\in$*) G where |H| = k do
    if cliqueDecision(H, k) then                    // we found it!
      return H                                      // so return the clique (subgraph)
\end{lstlisting}
If the assumed polynomial `cliqueDecision' algorithm runs in $O(n^j)$ time for some j,
then obviously our `cliqueOpt' algorithm takes $n*O(n^j) = O(n^{j+1})$ time for the first `for' loop,
plus up to $O(n^j) * O(n^{n-m})$ time for the second.
Still polynomial, still good. Boom.

\prob{12}
Laughable.
We can show that 2Clique is NP-hard by reducing a known NP-hard problem (in this case cliqueDecision) to it. That is, by showing
cliqueDecision $\leq$ 2Clique. This is easily done with the following code:


\prob{15}




\end{document}
