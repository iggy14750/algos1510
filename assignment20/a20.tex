\documentclass{article}
\author{Isaac B Goss\\ James Hahn\\ Jonathan Dyer}
\title{Assignment 20}

\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{enumitem}
\usepackage[margin=0.8in]{geometry}
\usepackage{graphicx}

% ============ USED FOR OUR FORMAT ============
\newtheorem{thm}{Claim}
\providecommand{\prob}[1]{\section*{Problem #1}}
\providecommand{\soln}{\textbf{Solution: }}
\providecommand{\image}[1]{
    \begin{center}
        \includegraphics%[width=0.95\textwidth]
            {#1}
    \end{center}
}
\providecommand{\tightlist}{
    \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}
}
\providecommand{\reducible}[2]{
  \textbf{#1} $\leq$ \textbf{#2}
}


% ============ USED FOR CODE LISTINGS ============
\usepackage{listings}
\usepackage[usenames,dvipsnames,svgnames]{xcolor}
\definecolor{javagreen}{rgb}{0.25,0.5,0.35}
\lstset{
    basicstyle   = \footnotesize,
    commentstyle = \color{javagreen},
    frame        = single,
    language     = C,
    stringstyle  = \color{orange},
    numbers      = left,
    showstringspaces=false,
    deletekeywords = {len, max, format, min},
    morekeywords = {yield, function, then, do, to},
    keywordstyle = \color{blue},
    escapeinside={(*}{*)}
}


\begin{document}
\maketitle
\prob{7}
Psh, trivial.
\begin{enumerate}
  \item \reducible{HamiltonianCycle}{DoubleFixedHamiltonianPath} \\
        This is straightforward.
  \begin{lstlisting}
HamiltonianCycle(Graph G)
    choose any v (*$\in$*) G
    return DoubleFixedHamiltonianPath(G, v, v)
  \end{lstlisting}

  \item \reducible{DoubleFixedHamiltonianPath}{HamiltonianCycle}
  \begin{lstlisting}
DoubleFixedHamiltonianPath(G, s, t)
    let H = G + (s,t)             // add edge (s,t) to graph
    return HamiltonianCycle(H)    // see if that makes a cycle
  \end{lstlisting}

  \item \reducible{SingleFixedHamiltonianPath}{DoubleFixedHamiltonianPath}
  \begin{lstlisting}
SingleFixedHamiltonianPath(G, s)
    for vertex v (*$\in$*) G do
        if DoubleFixedHamiltonianPath(G, s, v) then
            return true
    return false
  \end{lstlisting}

  \item \reducible{DoubleFixedHamiltonianPath}{SingleFixedHamiltonianPath}
  \begin{lstlisting}
DoubleFixedHamiltonianPath(G, s, t)
    if not (SFHP(G, s) and SFHP(G, t)) then
        return false
    C = G
    for edge e (*$\in$*) E(G) do
        if SFHP(C - e, s) and SFHP(C - e, t) then
            C = C - e
    if degree(*$_C$*)(s) == degree(*$_C$*)(s) == 1 then
        return true
    else return false

  \end{lstlisting}

\end{enumerate}

\prob{9}
SHOW ME WHAT YOU GOT.\\
This self-reduction is a matter of constructing a Hamiltonian Cycle from graph G using the information given by the decision algorithm.
So, to show \reducible{HamCycleOpt}{HamCycleDecision}, see the following code:
\begin{lstlisting}
HamCycleOpt(Graph G)
    C = G
    for edge uv (*$\in$*) E(G) do
        if HamCycleDecision(C - uv) then    // this means there's still a HamCycle in the graph
            C = C - uv                      // so get rid of the unnecessary edge
    return C                                // what's left is the Hamiltonian Cycle
\end{lstlisting}
Clearly this is a poly time algorithm, since it simply runs in time linear to the number of edges, i.e. size(G). So if HamCycleDecision takes $O(f(n))$ time, then HamCycleOpt as given above takes $O(f(n) + m)$ time, where m = size(G).

\end{document}
