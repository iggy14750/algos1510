\documentclass{article}
\author{Isaac B Goss\\ James Hahn\\ Jonathan Dyer}
\title{Assignment 31}

\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{amsfonts}
\usepackage{enumitem}
\usepackage[margin=0.8in]{geometry}
\usepackage{graphicx}

% ============ USED FOR OUR FORMAT ============
\newtheorem{thm}{Claim}
\providecommand{\prob}[1]{\section*{Problem #1}}
\providecommand{\soln}{\textbf{Solution: }}
\providecommand{\image}[1]{
    \begin{center}
        \includegraphics%[width=0.95\textwidth]
            {#1}
    \end{center}
}
\providecommand{\tightlist}{
    \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}
}
\providecommand{\reducible}[2]{
  \textbf{#1} $\leq$ \textbf{#2}
}
\providecommand{\R}{\mathbb{R}}

% ============ USED FOR CODE LISTINGS ============
\usepackage{listings}
\usepackage[usenames,dvipsnames,svgnames]{xcolor}
\definecolor{javagreen}{rgb}{0.25,0.5,0.35}
\lstset{
    basicstyle   = \footnotesize,
    commentstyle = \color{javagreen},
    frame        = single,
    language     = C,
    stringstyle  = \color{orange},
    numbers      = left,
    showstringspaces=false,
    deletekeywords = {len, max, format, min},
    morekeywords = {yield, function, then, do, to},
    keywordstyle = \color{blue},
    escapeinside={(*}{*)},
    mathescape
}


\begin{document}
\maketitle

\prob{21}

\begin{lstlisting}
function Smash(list)
    array = new int[|list|]
    By parPrefix(list), we know the position of each node.
    parFor i = 1 to 3n do
        if list[i] is a leaf node then
            array[i] = list[i]
    function inner(A)
        if |A| == 1 then
            return (null, null)
        left_head, left_tail = inner(A[0...n/2])
        right_head, right_tail = inner(A[n/2...n])
        if right_head == null then
            return (left_head, left_tail)
        else if left_head == null then
            return (right_head, right_tail)
        Connect left_tail to right_head.
        return (left_head, right_tail)
    return inner(array)
\end{lstlisting}

Or, in a less precise, but perhaps more straigt-forward style.

\begin{lstlisting}
function Smash(list)
    Each node finds its position in the list using linked list parPrefix
    Copy your element into an array at the position found before.
    If you are a node we want to get rid of, delete it from the array.
    Top-down recursion:
        On 1 element, return it as both head and tail of list.
        Otherwise, glue together the two lists and return that lists head and tail.
    Return that shit.
\end{lstlisting}

\prob{23}
This is quite similar to the problem described in class, of reducing an expression tree of addition and subtraction operations.
The major difference lies in the addition of multiplication and division as operatations.
This seems to have no effect on the algorithm discussed in class, except when performing contractions on the tree.

When working with addition and subtraction, we knew that every edge function was of the form $\pm x + c$ ($c \in \R$), and that combining two of these functions with either of our operations would leave the result of the same form.
That is, we knew that our functions were closed under the relevant operations.

The problem, then, is with multiplication.
When multiplying two functions of this form, we will have a quadratic function.
And that, in general, the size of these functions can then, in the worst case, grow to a degree linear in $n$.
So that is clearly unacceptable.

However, this problem will only arise on multiplication operations of two non-leaf children.
But, as discussed in class, reducing in such a situation doesn't make sense anyway.
For multiplication, this decision avoids the production of arbitrarily-growing polynomials.

In the case that one or both children are leaves, the actual value can be calculated in constant time.
That is, suppose we chose to reduce a node with two children.
One was a non-leaf, with the function $f(x)$ on the edge to it.
The other was a leaf with a value $k$, and a function $g(x)$ on the edge to it.
Then $g(k)$ can be calculated in constant time, and $g(k)*f(x)$ will still be a linear polynomial
(what we see here is that now our functions are general linear formulae, but this does not affect our algorithm or its runtime).

So, in this way, we can apply the exact same algorithm from class to success here.

\prob{24}
This is again a modification of the arithmetic trees in class.
In this case, we are also concerned with whether the Boolean functions on these edges will grow to unreasonable size.
It is not immediately obvious in this case that we can avoid this.
We might expect that some nasty expression like $\lnot(1 \land ((\lnot 0 \land x ) \lor 1))$ might appear.

Notice, however, that all edge functions are functions of one variable.
In Boolean logic, this constrains us to only 4 functions: 1, 0, identity, and inversion.
Moreover, they can be combined in constant time.
Let $f: \mathbb{B} \to \mathbb{B}$ be one of those Boolean function.

% I imagine there's a better table for this
\begin{align*}
    f \lor 1 &= 1\\
    f \lor 0 &= f\\
    f \land 1 &= f\\
    f \land 0 &= 0\\
    \lnot 1 &= 0\\
    \lnot 0 &= 1\\
    \lnot x &= \lnot x\\
    \lnot (\lnot x) &= x
\end{align*}

Note that again, at least one the arguments into the reductions are constant.
In the case of \verb|not|, the argument is a function, but one such function can be reduced in constant time, as well.

Therefore, all other aspects of our in-class algorithm are unchanged, meaning that we can use it here with this modification with success.


\end{document}
