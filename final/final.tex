\documentclass[12pt]{article}
\special{papersize=3in,5in}

\usepackage{amssymb,amsmath}
\newcommand{\R}{\mathbb{R}}
\newcommand{\N}{\mathbb{N}}
\providecommand{\st}{\ \text{s.t.}\ }
\providecommand{\tightlist}{
    \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}
}
\providecommand{\reducible}[2]{
  \textbf{#1} $\leq$ \textbf{#2}
}
\usepackage{listings}
\lstset{
  basicstyle=\ttfamily,
  mathescape
}


\pagestyle{empty}
\setlength{\parindent}{0in}
\begin{document}

\section{REDUCTIONS}
\subsection{\reducible{Matrix Mult}{Lower Triang Matrix Mult}}
\begin{lstlisting}
function matrixMult(A, B):
    C = [[0, 0, 0],
         [B, 0, 0],
         [0, A, 0]]
    D = [[0, 0, 0],
         [B, 0, 0],
         [0, A, 0]]
    E = lowerTriangeMult(C, D)
    return lower left(E)  //bottom-left entry is AB
\end{lstlisting}


\subsection{\reducible{Matrix Mult}{Matrix Inverse}}
\begin{lstlisting}
function matrixMult(A, B):
    C = [[I, A, 0],
         [0, I, B],
         [0, 0, I]]
    /**
     * Note now that C' = C-inverse is
     * D = [[I, -A, AB],
     *      [0,  I, -B],
     *      [0,  0,  I]]
     * This will be the output of our function matrixInverse(C)
     */
    D = matrixInverse(C)
    return upper right(D)
\end{lstlisting}


\subsection{\reducible{PolyMult}{PolySquare}}
Let $a$ and $b$ be polynomials.
We have that $(a+b)^2 = a^2 + 2ab + b^2$.
Or, $\displaystyle ab = \frac{(a+b)^2 - a^2 - b^2}{2}$.\\
\begin{lstlisting}
function PolyMult(A, B)
    AB = PolySquare(A + B)
    A2 = PolySquare(A)
    B2 = PolySquare(B)
    C = (AB - A2 - B2) / 2
    return C
\end{lstlisting}

\subsection{\reducible{Sort N Numbers}{Min Steiner Tree}}
Just like what we did in class with reducing "The Traveling Salesman" to sorting.
Simply create a coordinate for each number $i$ to be sorted in the form $(i,i)$,
giving you an adjacency list input that looks like $(a,a),(b,b), \dots, (n,n)$.
Then you'll get a graph that has a line (fun fact, it's $y=x$) which will contain,
in order from the origin, the sorted doubles of the numbers we want.
Then just extract the x-coordinate of every pair and you're golden.


\subsection{Graph Isomorphisms: \reducible{Directed}{Mixed}}
A directed graph is already technically a mixed graph,
so in your algorithm for directed graphs simply feed the assumed mixed graph algorithm your input.
Return the output.


\subsection{Graph Isomorphisms: \reducible{Undirected}{Directed}}
Given an undirected graph, simply make a copy of it with all edges replaced by
directed edge pairs to/from the endpoints of each (originally) undirected edge.
Feed this new directed graph to the assumed directed graph alg, then return the output.

\subsection{Graph Isomorphisms: \reducible{Mixed}{Undirected}}
In this one we've assumed an algo that checks isomorphisms of undirected graphs,
so the task is to convert a mixed graph into some number of undirected graphs that contain the same information.
This is easily achieved as follows:
\begin{itemize}
  \item First label the vertices in order, i.e. number them from $1,\dots,n$.
  \item Make one copy of the mixed graph with only edges where there were originally undirected edges in the mixed graph as well.
  \item Make another copy of the mixed graph with only edges where, in the original mixed graph, the lower-numbered endpoint had a directed edge $towards$ the higher-numbered endpoint.
  \item As above, but reversed (so the only edges here were originally directed edges from the higher endpoint to the lower endpoint).
\end{itemize}
Now do this process for both of the mixed graphs in question, say $F$ and $G$, and then feed the corresponding outputs into the assumed undirected algorithm. If they all check out, then $F$ and $G$ are isomorphic.


\subsection{\reducible{Independent Set}{Clique}, and \reducible{Clique}{Independent Set}}
We define the complement of some graph $G$, labelled $G^C$ to be a graph such that
\begin{enumerate}
  \item $V(G) = V(G^C)$
  \item $uv \in E(G^C)$ iff $u,v \in V(G^C)$ and $uv \not\in E(G)$.
\end{enumerate}
An independent set of vertices are a subset of vertices which are all pairwise non-adjacent.
Likewise, a clique is a subset of vertices which are all pairwise adjacent.
In the complement of some graph, all independent sets become cliques, and vice versa.
Thus we have the following reductions:
\begin{lstlisting}
function IndependentSet(G, i)
return Clique((*$G^C$*), i)
\end{lstlisting}
\begin{lstlisting}
function Clique(G, i)
return IndependentSet((*$G^C$*), i)
\end{lstlisting}


\subsection{\reducible{Independent Set}{Vertex Cover} and \reducible{Vertex Cover}{Independent Set}}
We can define a relationship between these two problems, by noting the following:
\begin{itemize}
  \item Define graph $G$ by its set of vertices and edges, as $G = (V,E)$.
  \item Note that if $L \subset V$ is an independent set, then for any two neighboring vertices $u$ and $v$, at most one of them is in $L$ or else it wouldn't be an independent set. So then at $least$ one of every pair of neighbors is in $M = V - L$. Thus every edge in $E$ has an endpoint in $M$, so $M$ is a vertex cover.
  \item Conversely, if $M \subset V$ is a vertex cover, then consider any two vertices $x$ and $y$ in $L = V - M$. These two points can't be neighbors, else $M$ wouldn't be a cover. Thus no two points in $L$ are adjacent, so it must be an independent set.
\end{itemize}
\begin{lstlisting}
function IndependentSet(G, k)
return VertexCover(G, n - k)
\end{lstlisting}
\begin{lstlisting}
function VertexCover(G, k)
return IndependentSet(G, n - k)
\end{lstlisting}

\subsection{\reducible{CliqueOpt}{CliqueDecision}}
We can reduce the clique optimization problem to clique decision by simply checking every value of $k$,
beginning at $n = |G|$ and decrementing.
Follow this by a closure operation which removes all vertices with degree less than k-1,
so that only the clique is left.
\begin{lstlisting}
alg cliqueOpt(Graph G)
  let n = |G|
  for k = n to 1 do
    if cliqueDecision(G, k) then                    // we found the largest clique size
      break                                         // so break and find the members

  let H = G
  do
    G = H
    for vertex v in H:
      if degree(v) < k-1 then
        delete v from H
  until H == G

  output H
\end{lstlisting}

\subsection{\reducible{CliqueDecision}{2Clique}}
We can show that 2Clique is NP-hard by reducing another known NP-hard problem (here cliqueDecision) to it.
That is, we must show that cliqueDecision $\leq$ 2Clique in polynomial time.
We do this by giving an algorithm for cliqueDecision that uses 2Clique:
\begin{lstlisting}
alg cliqueDecision(H,j)   // simply create a new graph which is two copies of the original
  let G = H + H           // if this new graph has two cliques of the desired size, then
  return 2Clique(G,j)     // clearly the original has one
\end{lstlisting}
Obviously, creating a new graph that is just two copies of the original graph H takes $O(n)$ time, which when added to our cliqueDecision algorithm results in a total runtime of $O(n + f(n))$, where $f(n)$ is the runtime of cliqueDecision.


\subsection{\reducible{HamiltonianCycle}{DoubleFixedHamiltonianPath}}
\begin{lstlisting}
HamiltonianCycle(Graph G)
  choose any v (*$\in$*) G
  return DoubleFixedHamiltonianPath(G, v, v)
\end{lstlisting}

\subsection{\reducible{DoubleFixedHamiltonianPath}{HamiltonianCycle}}
\begin{lstlisting}
DoubleFixedHamiltonianPath(G, s, t)
  let H = G + (s,t)             // add edge (s,t) to graph
  return HamiltonianCycle(H)    // see if that makes a cycle
\end{lstlisting}

\subsection{\reducible{SingleFixedHamiltonianPath}{DoubleFixedHamiltonianPath}}
\begin{lstlisting}
SingleFixedHamiltonianPath(G, s)
  for vertex v (*$\in$*) G do
      if DoubleFixedHamiltonianPath(G, s, v) then
          return true
  return false
\end{lstlisting}

\subsection{\reducible{DoubleFixedHamiltonianPath}{SingleFixedHamiltonianPath}}
\begin{lstlisting}
DoubleFixedHamiltonianPath(G, s, t)
  if not (SFHP(G, s) and SFHP(G, t)) then
      return false
  C = G
  for edge e (*$\in$*) E(G) do
      if SFHP(C - e, s) and SFHP(C - e, t) then
          C = C - e
  if degree(*$_C$*)(s) == degree(*$_C$*)(s) == 1 then
      return true
  else return false
\end{lstlisting}
At the end of this process if we've removed all unnecessary edges whilst ensuring that paths starting at each endpoint are
intact, then neither will be left with more than one incident edge.

\subsection{\reducible{HamCycleOpt}{HamCycleDecision}}
\begin{lstlisting}
HamCycleOpt(Graph G)
    C = G
    for edge uv (*$\in$*) E(G) do
        if HamCycleDecision(C - uv) then    // this means there's still a HamCycle in the graph
            C = C - uv                      // so get rid of the unnecessary edge
    return C                                // what's left is the Hamiltonian Cycle
\end{lstlisting}


\subsection{\reducible{Clique}{$\dfrac{3}{4}$Clique}}
Check Max's solutions.

\subsection{\reducible{IndependentSet}{$\dfrac{3}{4}$IndependentSet}}
Check Max's solutions.


\subsection{\reducible{Clique}{CliqueAndInd}}
\begin{lstlisting}
function Clique(Graph G, int k)
    let H = new independent set of k vertices
    if CliqueAndInd(G+H,k)  // if the known independent set plus G passes the AND test,
        return 1            // then G$\ni$(k-clique)
\end{lstlisting}


\subsection{\reducible{Clique}{CliqueOrInd}}
We simply need to eliminate any independent set in G without compromising a possible clique.
The easiest way to do this is to simply add a new vertex and connect it to all vertices in G.
Then any clique will just be one vertex larger, which is of course fine since (k+1)-cliques of course contain k-cliques.
\begin{lstlisting}
function Clique(Graph G, int k)
    let H = G $\times$ v    // cross product of G and one vertex
    return CliqueOrInd(H, k)
\end{lstlisting}


\subsection{$\dfrac{3}{4}$Clique AND $\dfrac{3}{4}$IndependentSet}
Polynomial time algorithm! (via Max)

\subsection{\reducible{IndependentSet}{$\dfrac{3}{4}$Clique OR $\dfrac{3}{4}$IndependentSet}}
Check Max's solutions.

\subsection{\reducible{CNF-SAT}{Linear Inequality}}
Create a set of inequalities S as follows:\\
\begin{itemize}
  \item For each variable $x_i$ in boolean formula F, create integer var $x_i$.
  \item Add inequalities $x_i \geq 0$ and $x_i \leq 1$ to make it either 0 or 1.
  \item For each disjunction make a sum: if literal is $x_i$, add $x_i$; if $\overline{x_i}$, add $(1-x_i)$. Require the sum to be at least 1.
  \item This set of inequalities S is satisfied iff F is satisfied.
\end{itemize}

\subsection{\reducible{3-coloring}{CNF-SAT}}
\begin{itemize}
  \item For each vertex $x$ in $G$, create $x_{red}$, $x_{blue}$, and $x_{green}$.
  \item Exactly one of those must be true for each vertex $x$.
  \item For each neighbor $y$ of $x$, we must have ($x_{color} \lor y_{color}$).
  \item Just "and" together all vertex clauses constructed above.
\end{itemize}

\subsection{\reducible{Vertex Cover}{Dominating Set}}
Note: 'dominating set' = set S s.t. every vertex $v \in G$ is either in S or adjacent to S.
\begin{itemize}
  \item Make $G'$ by replacing each edge $e = (x,y)$ in $G$ by new vertex $v_e$ and edges $(x,v_e),(y,v_e),$ and $(x,y)$.
  \item Note: the vertex $v_e$ forces edge $e$ to be covered by a dominating set.
  \item Get minimum dominating set, call it $D$. If any $v_e \in D$, replace $v_e$ by $x$ (or $y$). Call this new set $D'$.
  \item Note that $D'$ is still dominating in $G'$, therefore we have a minimum cardinality vertex cover.
\end{itemize}


\subsection{\reducible{IndependentSet}{TriadFree}}
????


\subsection{\reducible{3Color}{Planar3Color}}
????


\subsection{\reducible{VertexCover}{StrangeSubsetTraverse}}
????


\subsection{\reducible{3SAT}{DisjointPaths}}
????


\subsection{\reducible{3SAT}{TriangleProblem}}
????



\subsection{\reducible{TriangleProblem}{DrCuddyDiseases}}
????


\subsection{\reducible{VertexCover}{Fox,Goose,BoB}}
????





\section{PARALLEL ALGORITHMS}
\subsection{AND of $n$ bits}
\subsubsection{AND -- O(lg(n)), n procs, EREW}
\begin{itemize}\tightlist
  \item Recurse, halving the input size every time (AND-ing pairs of bits)
  \item This way it takes lg(height of call tree) = lg(n) constant time activations
  \item $E(n,n) = \frac{1}{lg(n)}$
\end{itemize}
\subsubsection{AND -- O(lg(n)), n/lg(n) procs, EREW}
\begin{itemize}\tightlist
  \item Start by AND-ing lg(n) bits with each processor
  \item Recurse, halving the results every time (AND-ing pairs of bits)
  \item This way it takes lg(height of call tree) = lg($\frac{n}{lg(n)}$) constant time activations
  \item $T(n) = \theta(lg(n))$ | $E(n,n) = 1$
\end{itemize}\tightlist
\subsubsection{AND -- O(1), n procs, CRCW Common}
\begin{lstlisting}
parFor each processor $p_i$ (pointing to unique bit)
    if bit $i$ == 0, then RESULT = FALSE
\end{lstlisting}


\subsection{\reducible{Boolean Formula Value}{New Problem N}}
Write an alg $A$ for the boolean formula value problem that:\\
\begin{enumerate}\tightlist
  \item Only lacks code for problem N
  \item Runs in poly-log time w/ a poly # of procs
\end{enumerate}
Then you'd have it...


\subsection{ARRAY of $n$ ints}
\subsubsection{ARRAY -- O(lg(n)), n procs, EREW}
\begin{lstlisting}
ARR($A[1] \dots A[n], x, p$)
  if p == 1 then $A[1] = x$
  else (*\(
        \left \{
            \begin{tabular}{l}
            ARR($A[1] \dots A[\frac{n}{2}], x, \frac{p}{2}$) \\
            ARR($A[\frac{n}{2}+1] \dots A[n], x, \frac{p}{2}$)
            \end{tabular}
        \right \}
        \)*)
\end{lstlisting}
$E(n,n) = \frac{1}{lg(n)}$
\subsubsection{ARRAY -- O(lg(n)), n/lg(n) procs, EREW}
\begin{lstlisting}
logARR($A[1] \dots A[n], x, p$)
  if p == 1 then SequentialARR($A[1] \dots A[n]$)
  else (*\(
        \left \{
            \begin{tabular}{l}
            logARR($A[1] \dots A[\frac{n}{2}], x, \frac{p}{2}$) \\
            logARR($A[\frac{n}{2}+1] \dots A[n], x, \frac{p}{2}$)
            \end{tabular}
        \right \}
        \)*)
\end{lstlisting}
$T(n) = \theta(lg(n))$ | $E(n,n) = 1$
\subsubsection{ARRAY -- O(1), n procs, CRCW Common}
Concurrently read $x$ with each processor, then concurrently write $x$ into $A[i]$ for each $i \in [n]$.\\
$E(n,p) = E(n,n) = \frac{n}{n*1} = 1$


\subsection{ParPrefix -- O(lg(n)), n/lg(n) procs, EREW}
????


\subsection{$n$ factorial -- O(lg(n)), n procs, EREW}
????



\subsection{MatMult of 2 $n\times n$ matrices}
\subsubsection{MatMult -- O(n), $n^2$ procs, CREW}
????
\subsubsection{MatMult -- O(lg(n)), $n^3$ procs, CREW}
????
\subsubsection{MatMult -- O(lg(n)), $n^3$/lg(n) procs, CRCW Common}
????
\subsubsection{MatMult -- O(lg(n)), $n^3$/lg(n) procs, EREW}
????


\subsection{Polynomial $p(x)$, compute $p(k)$ -- O(lg(n)), n procs, EREW}
????


\subsection{Prefix-Suffix -- poly-log, poly procs, EREW}
????


\subsection{Prefix-Suffix -- constant, poly procs, CRCW Common}
????


\subsection{ADD 2 $n$-bit ints}
\subsubsection{ADD -- O(lg(n)), n procs, CREW}
????
\subsubsection{ADD -- O(lg$^2$(n)), n procs, EREW}
????


\subsection{AllPairsShortestPath -- O(lg$^2$(n)), $n^3$ procs, EREW}
????

\subsection{AllPairsShortestPath, return paths -- O(lg$^2$(n)), $n^3$ procs, EREW}
????


\subsection{Min Edit Distance -- poly-log, poly procs, CREW}
????


\subsection{MERGE 2 sorted arrays -- O(1), poly procs, CRCW Common}
????


\subsection{MAX of $n$ ints -- O(lg(lg(n))), n procs, CRCW Common}
????

\subsection{MAX of $n$ ints $\leq n$ -- O(1), n procs, CRCW Priority}
????

\subsection{MAX of $n$ ints $\leq n$ -- O(1), n procs, CRCW Common}
????


\subsection{COMPOSE arrays -- O(lg$^2$(n)), n procs, EREW}
????

\subsection{BINARY TREE, number leaves -- O(lg(n)), n procs, EREW}
????


\subsection{BINARY TREE, balance factor -- O(lg(n)), n procs, EREW}
????


\subsection{BINARY EXPRESSION TREE, evaluate -- O(lg$^2$(n)), n procs, CREW}
????

\subsection{BINARY BOOL EXPRESSION TREE, evaluate -- O(lg$^2$(n)), n procs, CREW}
????








\end{document}



\begin{centering}\textbf{Gas Station pt 1}\par\end{centering}
